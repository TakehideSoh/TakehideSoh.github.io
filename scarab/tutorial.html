<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-02-26 火 02:14 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Scarab チュートリアル</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Takehide Soh" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-6313627-5"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-6313627-5');
</script>
<link rel="stylesheet" type="text/css" href="../myhome.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Scarab チュートリアル</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. 参考資料</a></li>
<li><a href="#orgheadline2">2. インストール</a></li>
<li><a href="#orgheadline3">3. 実行の方法</a></li>
<li><a href="#orgheadline6">4. REPL による対話的な実行方法</a>
<ul>
<li><a href="#orgheadline4">4.1. CSP の定義</a></li>
<li><a href="#orgheadline5">4.2. 解の探索</a></li>
</ul>
</li>
<li><a href="#orgheadline8">5. スクリプトファイルの読み込み</a>
<ul>
<li><a href="#orgheadline7">5.1. 練習問題</a></li>
</ul>
</li>
<li><a href="#orgheadline15">6. 簡単な例題</a>
<ul>
<li><a href="#orgheadline10">6.1. 部分和問題</a></li>
<li><a href="#orgheadline12">6.2. 魔方陣</a></li>
<li><a href="#orgheadline13">6.3. 正方形矩形パッキング</a></li>
<li><a href="#orgheadline14">6.4. その他の例題</a></li>
</ul>
</li>
<li><a href="#orgheadline31">7. その他 Scarab の説明クラスとメソッドの簡単なまとめ</a>
<ul>
<li><a href="#orgheadline16">7.1. jar ファイルとソースコード</a></li>
<li><a href="#orgheadline17">7.2. Scarab DSL の制約記述に関する構文 (BNF記法)</a></li>
<li><a href="#orgheadline20">7.3. Scarab のクラス図</a></li>
<li><a href="#orgheadline30">7.4. プログラムの簡単なまとめ</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> 参考資料</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Scarab 資料
<ul class="org-ul">
<li><a href="http://tsoh.org/scarab/">ホームページ</a></li>
<li><a href="https://github.com/TakehideSoh/Scarab">github</a></li>
</ul></li>
<li>プレゼンテーション
<ul class="org-ul">
<li>Scarab の説明 @ ScalaMatsuri 2014
<ul class="org-ul">
<li><a href="https://tsoh.org/scarab/talks/talk-jp-scalamatsuri.pdf">日本語</a></li>
<li><a href="https://tsoh.org/scarab/talks/talk-en-scalamatsuri.pdf">英語</a></li>
</ul></li>
<li>AIツールセミナー (2015年12月)
<ul class="org-ul">
<li><a href="https://tsoh.org/scarab/talks/ai-tool-soh-1.pdf">SAT型制約ソルバーと Scarab</a></li>
<li><a href="https://tsoh.org/scarab/talks/ai-tool-soh-2.pdf">alldiffrent制約を例に用いた制約の拡張</a></li>
</ul></li>
<li><a href="https://tsoh.org/scarab/talks/talk-jp-ppl2017.pdf">SATソルバーの最新動向と利用技術 (日本語) @ PPL 2017</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> インストール</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li><a href="https://www.scala-lang.org/download/">Scala のページ</a> から sbt をダウンロードしてインストールする．
<ul class="org-ul">
<li>ターミナルや PowerShell 等を起動して sbt を実行できれば OK.</li>
<li>環境によってはパスを設定する必要がある．</li>
</ul></li>
<li><a href="./sbt-scarab.zip">sbt-scarab.zip</a> をダウンロードして適当なディレクトリに展開する．</li>
<li><p>
sbt-scarab のディレクトリに入って sbt を実行すれば必要なライブラリ
(scala を含む) のダウンロードとコンパイルが行われる．
</p>
<div class="org-src-container">

<pre class="src src-sh">[sbt-scarab]$ sbt
</pre>
</div></li>
<li><p>
以下のように sbt:Scarab&gt; というプロンプトが出てくればインストール完了となる．
</p>
<div class="org-src-container">

<pre class="src src-sh">[sbt-scarab]$ sbt
[info] Loading settings from assembly.sbt ...
... &#20013;&#30053; ...
[info] sbt server started at 127.0.0.1:4891
sbt:Scarab&gt;
</pre>
</div></li>
<li><p>
exit で終了できる．
</p>
<div class="org-src-container">

<pre class="src src-sh">sbt:Scarab&gt; exit 
[sbt-scarab]$
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">3</span> 実行の方法</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>Scarab の制約記述言語は Scala 上のドメイン特化言語として実装されている． <a href="ref.html">Scala の説明</a></li>
<li>Scala と同じく3つの方法でプログラムを記述し，実行できる．
<ul class="org-ul">
<li>REPL (Read Eval Print Loop) による対話的な実行方法</li>
<li>スクリプトによるコンパイル不要な実行方法</li>
<li>scalac で実行形式にコンパイルしてから実行する方法</li>
</ul></li>
<li>本チュートリアルでは REPL による対話的な実行方法を通して scarab を説明する．</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">4</span> REPL による対話的な実行方法</h2>
<div class="outline-text-2" id="text-4">
<p>
簡単な例題を通して, Scala の REPL (対話的実行環境) を用いた scarab の利用方法を理解しよう.
</p>
<pre class="example">
=== 問題 ===
12セント，16セント，20セント，27セントの切手をそれぞれ10枚持っている．
この時に90セント分の切手を構成できるか?
</pre>
<p>
この問題は以下のように制約充足問題 (CSP) として定義できる．
</p>
<blockquote>
<p>
<code>=</code> 切手の問題の CSP による定義 <code>=</code>
</p>
<ul class="org-ul">
<li>変数の集合 \(X = \{a, b, c, d\}\)</li>
<li>変数が取り得る値の集合 (ドメイン) を表す関数 \(Dom\)
<ul class="org-ul">
<li>\(Dom(a) = \{0, \ldots, 10\}\)</li>
<li>\(Dom(b) = \{0, \ldots, 10\}\)</li>
<li>\(Dom(c) = \{0, \ldots, 10\}\)</li>
<li>\(Dom(d) = \{0, \ldots, 10\}\)</li>
</ul></li>
<li>制約条件 \(C\)
<ul class="org-ul">
<li>\(12a + 16b + 20c + 27d = 90\)</li>
</ul></li>
</ul>
</blockquote>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">4.1</span> CSP の定義</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>上記のCSPに対応するScarabプログラムは以下になる</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._

int('a, 0, 10)
int('b, 0, 10)
int('c, 0, 10)
int('d, 0, 10)

add('a * 12 + 'b * 16 + 'c * 20 + 'd * 27 === 90)
</pre>
</div>
<ul class="org-ul">
<li>このプログラムを REPL (対話的な実行方法) で記述実行するために, sbt-scarab ディレクトリで sbt コマンド実行後に, console を実行する. すると最終的に scala&gt; というコンソールが立ち上げる.</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">[sbt-scarab]$ sbt
sbt:Scarab&gt; console
... &#12513;&#12483;&#12475;&#12540;&#12472;&#30465;&#30053; ...
scala&gt;
</pre>
</div>
<ul class="org-ul">
<li>これで scala の REPL モードが scarab のクラスを読み込んで起動された．</li>
<li>次に scarab のクラスをインポートする.</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; <span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._
<span style="color: #a020f0;">import</span> jp.kobe_u.scarab._
<span style="color: #a020f0;">import</span> dsl._
</pre>
</div>
<ul class="org-ul">
<li>import 文が読み込まれ (Read Eval) 実行結果が表示 (Print) される.</li>
<li>整数変数を定義する.</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; int('a, 0, 10)
res0: jp.kobe_u.scarab.Var = a

scala&gt; int('b, 0, 10)
res1: jp.kobe_u.scarab.Var = b

scala&gt; int('c, 0, 10)
res2: jp.kobe_u.scarab.Var = c

scala&gt; int('d, 0, 10)
res3: jp.kobe_u.scarab.Var = d
</pre>
</div>
<ul class="org-ul">
<li>ここでは変数a, b, c, dを宣言している (下限 0，上限 10)． シングルクォーテーションから始まる記述 &rsquo;x は ScalaにおけるSymbolオブジェクトの記法だが， Scarab DSLによりScarabの整数変数 (Varオブジェクト) に暗黙変換される.</li>
<li>制約を定義する.</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; add('a * 12 + 'b * 16 + 'c * 20 + 'd * 27 === 90)
res4: jp.kobe_u.scarab.Constraint = EqZero(Sum(-90+12*a+16*b+20*c+27*d))
</pre>
</div>
<ul class="org-ul">
<li>ここでは制約 12a + 16b + 20c + 27d = 90 を追加している. 
<ul class="org-ul">
<li>add は制約をCSPオブジェクトに追加するためのメソッドである.</li>
<li>制約中での等号に \(===\) を用いる点に注意されたい.</li>
<li>5 * &rsquo;a のように係数を前にして記述できない点にも注意されたい.</li>
</ul></li>
<li>定義したCSPオブジェクトは変数cspとして参照できる.</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; csp
res8: jp.kobe_u.scarab.CSP = CSP(Vector(a, b, c, d),Vector(),Map(..),Vector(..))
</pre>
</div>
<ul class="org-ul">
<li>CSPオブジェクトは，整数変数の列 variables, ブール変数の列 bools,
変数ドメインのマップ dom, 制約の列 constraints から構成される.</li>
<li>以下のように csp オブジェクトから参照できる.</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; csp.variables
res5: IndexedSeq[jp.kobe_u.scarab.Var] = Vector(a, b, c, d)

scala&gt; csp.constraints
res6: IndexedSeq[jp.kobe_u.scarab.Constraint] = Vector(EqZero(Sum(-90+12*a+16*b+20*c+27*d)))
</pre>
</div>
<ul class="org-ul">
<li>show メソッドでも表示できる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; csp.show
int(a,Domain(0 to 10))
int(b,Domain(0 to 10))
int(c,Domain(0 to 10))
int(d,Domain(0 to 10))
EqZero(Sum(-90+12*a+16*b+20*c+27*d))
</pre>
</div>
<ul class="org-ul">
<li>CSPオブジェクトは，変数や制約の追加を行える mutable なオブジェクトとして実装されている．</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">4.2</span> 解の探索</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>最初の解の探索は find で行う．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; find
res9: Boolean = <span style="color: #008b8b;">true</span>
</pre>
</div>
<ul class="org-ul">
<li>結果の true は，解が存在することを表す． CSPの解は，solution 変数に代入されている．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; solution
res10: jp.kobe_u.scarab.Assignment = Assignment(Map(a -&gt; 3, b -&gt; 0, c -&gt; 0, d -&gt; 2),Map())
</pre>
</div>
<ul class="org-ul">
<li>Solutionオブジェクトは，整数変数 (Varオブジェクト)に対する値割当てを表すマップと ブール変数 (Boolオブジェクト)に対する値割当てを表すマップから構成される．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; solution.intMap
res11: Map[jp.kobe_u.scarab.Var,Int] = Map(a -&gt; 3, b -&gt; 0, c -&gt; 0, d -&gt; 2)

scala&gt; solution.boolMap
res12: Map[jp.kobe_u.scarab.Bool,Boolean] = Map()
</pre>
</div>
<ul class="org-ul">
<li>解における各変数の値は solution メソッドで得ることができる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; solution('a)
res13: Int = 3

scala&gt; solution('b)
res14: Int = 0

scala&gt; solution('c)
res15: Int = 0

scala&gt; solution('d)
res16: Int = 2
</pre>
</div>
<ul class="org-ul">
<li>次の解の探索は findNext で行う．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; findNext
res17: Boolean = <span style="color: #008b8b;">true</span>

scala&gt; solution
res18: jp.kobe_u.scarab.Assignment = Assignment(Map(a -&gt; 0, b -&gt; 1, c -&gt; 1, d -&gt; 2),Map())
</pre>
</div>
<ul class="org-ul">
<li>findNext は最も最近得られた解の否定をcspに追加することで次の解を求めている．</li>
<li>show メソッドを実行すると，制約が追加されていることが分かる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">int(a,Domain(0 to 10))
int(b,Domain(0 to 10))
int(c,Domain(0 to 10))
int(d,Domain(0 to 10))
LeZero(Sum(-90+12*a+16*b+20*c+27*d))
LeZero(Sum(90-12*a-16*b-20*c-27*d))
Or(LeZero(Sum(-2+a)),LeZero(Sum(4-a)),LeZero(Sum(1+b)),LeZero(Sum(1-b)),LeZero(Sum(1+c)),LeZero(Sum(1-c)),LeZero(Sum(-1+d)),LeZero(Sum(3-d)))
</pre>
</div>
<ul class="org-ul">
<li>ここでこの次の解の探索時には，最初に解を求めた時の学習節を再利用するインクリメンタルSAT解法を行っている．</li>
<li>Scarab では明示的にSATソルバーを reset しない限り，常に学習節を保持して効率的に求解を行う．</li>
<li>もう一度 findNext を呼ぶと false が返る．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; findNext
res22: Boolean = <span style="color: #008b8b;">false</span>
</pre>
</div>
<ul class="org-ul">
<li>結果の false は，解が存在しないことを表す． この場合，変数 solution は null になっている．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; solution
res23: jp.kobe_u.scarab.Assignment = <span style="color: #008b8b;">null</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">5</span> スクリプトファイルの読み込み</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>CSPをScalaのスクリプトファイルとして定義することもできる．</li>
<li>以下がCSPを定義したスクリプトファイルである.
<ul class="org-ul">
<li><a href="http://tsoh.org/scarab/sample-scripts/ex-csp.sc">http://tsoh.org/scarab/sample-scripts/ex-csp.sc</a></li>
</ul></li>
</ul>
<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._

int('a, 0, 10)
int('b, 0, 10)
int('c, 0, 10)
int('d, 0, 10)
add('a * 12 + 'b * 16 + 'c * 20 + 'd * 27 === 90)
</pre>
</div>
<ul class="org-ul">
<li>以下がCSPを定義した後に求解し，解があれば出力するスクリプトファイルである.
<ul class="org-ul">
<li><a href="http://tsoh.org/scarab/sample-scripts/ex-csp-solve.sc">http://tsoh.org/scarab/sample-scripts/ex-csp-solve.sc</a></li>
</ul></li>
</ul>
<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._

int('a, 0, 10)
int('b, 0, 10)
int('c, 0, 10)
int('d, 0, 10)
add('a * 12 + 'b * 16 + 'c * 20 + 'd * 27 === 90)

<span style="color: #a020f0;">if</span> (find) println(solution)
</pre>
</div>

<ul class="org-ul">
<li>スクリプトファイルは以下のようにREPLから :load コマンドを使用して読
み込む (カレントディレクトリにファイルがあるものとする)．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; :load ./ex-csp.sc
Loading ./ex-csp.sc...
<span style="color: #a020f0;">import</span> jp.kobe_u.scarab._
<span style="color: #a020f0;">import</span> dsl._
res0: jp.kobe_u.scarab.Var = a
res1: jp.kobe_u.scarab.Var = b
res2: jp.kobe_u.scarab.Var = c
res3: jp.kobe_u.scarab.Var = d
res4: jp.kobe_u.scarab.Constraint = EqZero(Sum(-90+12*a+16*b+20*c+27*d))
</pre>
</div>
<ul class="org-ul">
<li>スクリプトファイルの内容を変更した後，再度読み込みたい場合には，:load の前に reset (scarab のコマンド) を実行し，いったんCSPの定義を消去する必要がある．</li>
</ul>

<div class="org-src-container">

<pre class="src src-scala">scala&gt; reset

scala&gt; :load ./ex-csp.sc
Loading ./ex-csp.sc...
<span style="color: #a020f0;">import</span> jp.kobe_u.scarab._
<span style="color: #a020f0;">import</span> dsl._
res13: jp.kobe_u.scarab.Var = a
res14: jp.kobe_u.scarab.Var = b
res15: jp.kobe_u.scarab.Var = c
res16: jp.kobe_u.scarab.Var = d
res17: jp.kobe_u.scarab.Constraint = EqZero(Sum(-90+12*a+16*b+20*c+27*d))
</pre>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">5.1</span> 練習問題</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>89円分の切手を構成できるかテストしてみよう．</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">6</span> 簡単な例題</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">6.1</span> 部分和問題</h3>
<div class="outline-text-3" id="text-6-1">
<pre class="example">
使いきらなければならない予算が 50 千円あります．
購入できる品物は 2, 3, 5, 8, 13, 21, 34 (単位: 千円) が1つずつです．
ちょうど予算を使い切るような組合せはあるか?
</pre>

<ul class="org-ul">
<li>この問題は 部分和問題 (Subset sum problem)として知られている問題の例である． 部分和問題はNP-完全である (<a href="https://ja.wikipedia.org/wiki/%E9%83%A8%E5%88%86%E5%92%8C%E5%95%8F%E9%A1%8C">Wikipedia:部分和問題</a>)．</li>
<li>これは，以下の制約充足問題として定式化できる．</li>
</ul>
<blockquote>
<ul class="org-ul">
<li>\(X = \{x_2, x_3, x_5, x_8, x_{13}, x_{21}, x_{34}\}\)</li>
<li>\(Dom\)
<ul class="org-ul">
<li>\(Dom(x_2) = \{0, 1\}\)</li>
<li>\(Dom(x_3) = \{0, 1\}\)</li>
<li>\(Dom(x_5) = \{0, 1\}\)</li>
<li>\(Dom(x_8) = \{0, 1\}\)</li>
<li>\(Dom(x_{13}) = \{0, 1\}\)</li>
<li>\(Dom(x_{21}) = \{0, 1\}\)</li>
<li>\(Dom(x_{34}) = \{0, 1\}\)</li>
</ul></li>
<li>\(C\)
<ul class="org-ul">
<li>\(2x_2 + 3x_3 + 5x_5 + 8x_8 + 13x_{13} + 21x_{21} + 34x_{34} = 50\)</li>
</ul></li>
</ul>
</blockquote>
<ul class="org-ul">
<li>CSPを記述したファイルは以下のようになる <a href="https://tsoh.org/scarab/sample-scripts/ex-subsetsum.sc">ex-subsetsum.sc</a></li>
</ul>
<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._ 

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">define</span>(<span style="color: #a0522d;">sum</span>: <span style="color: #228b22;">Int</span>) {
  reset
  boolInt('x(2))
  boolInt('x(3))
  boolInt('x(5))
  boolInt('x(8))
  boolInt('x(13))
  boolInt('x(21))
  boolInt('x(34))
  add('x(2)*2 + 'x(3)*3 + 'x(5)*5 + 'x(8)*8 + 'x(13)*13 + 'x(21)*21 + 'x(34)*34 === sum)
}
</pre>
</div>

<ul class="org-ul">
<li>boolInt は 0-1 変数の宣言であり， boolInt(x) は int(x, 0, 1) と同一である．</li>
<li>また上記プログラムでは，直接CSPを記述するのではなく， 関数 define(sum: Int) で和を与えられるようにしている． この場合，利用方法は以下のようになる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; :load ./ex-subsetsum.sc
Loading ./ex-subsetsum.sc...
<span style="color: #a020f0;">import</span> jp.kobe_u.scarab._
<span style="color: #a020f0;">import</span> dsl._
define: (sum: Int)Unit

scala&gt; define(50)

scala&gt; find
res1: Boolean = <span style="color: #008b8b;">true</span>

scala&gt; solution
res2: jp.kobe_u.scarab.Assignment = Assignment(Map(x(8) -&gt; 1, x(21) -&gt; 1, x(3) -&gt; 1, x(13) -&gt; 1, x(2) -&gt; 0, x(34) -&gt; 0, x(5) -&gt; 1),Map())
</pre>
</div>
<ul class="org-ul">
<li>解が見にくいが，以下のようにすれば見やすくなる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; <span style="color: #a020f0;">for</span> (x &lt;- csp.variables) println(s<span style="color: #8b2252;">"$x ${solution(x)}"</span>)
x(2) 0
x(3) 1
x(5) 1
x(8) 1
x(13) 1
x(21) 1
x(34) 0
</pre>
</div>
<ul class="org-ul">
<li>この解は 3, 5, 8, 13, 21 (単位: 千円) の品物を買えば 50 千円になることを表している．</li>
<li>34 千円の品物が入った解が欲しい場合は，以下のように制約を追加して解を求めれば良い．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; add('x(34) === 1)
res6: jp.kobe_u.scarab.Constraint = EqZero(Sum(-1+x(34)))

scala&gt; find
res7: Boolean = <span style="color: #008b8b;">true</span>

scala&gt; solution
res8: jp.kobe_u.scarab.Assignment = Assignment(Map(x(8) -&gt; 0, x(21) -&gt; 0, x(3) -&gt; 1, x(13) -&gt; 1, x(2) -&gt; 0, x(34) -&gt; 1, x(5) -&gt; 0),Map())

scala&gt; <span style="color: #a020f0;">for</span> (x &lt;- csp.variables) println(s<span style="color: #8b2252;">"$x ${solution(x)}"</span>)
x(2) 0
x(3) 1
x(5) 0
x(8) 0
x(13) 1
x(21) 0
x(34) 1
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline9"></a>練習問題<br  /><div class="outline-text-4" id="text-6-1-1">
<ul class="org-ul">
<li>和が40の場合はどうなるか?</li>
</ul>
</div></li></ol>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">6.2</span> 魔方陣</h3>
<div class="outline-text-3" id="text-6-2">
<pre class="example">
1から9の数字を 3×3 に配置し， 各行，各列，各対角線の和がいずれも15になるようにせよ．
</pre>

<ul class="org-ul">
<li>このような配置は魔方陣 (Magic square)と呼ばれる (<a href="http://ja.wikipedia.org/wiki/%E9%AD%94%E6%96%B9%E9%99%A3">Wikipedia:魔方陣</a>)．</li>
<li>以下のようにCSPとして定式化できる．</li>
</ul>

<blockquote>
<ul class="org-ul">
<li>\(X = \cup_{0 \le i,j \le 2} x_{i,j} \)
<ul class="org-ul">
<li>\(x_{0,0}, x_{0,1}, \ldots, x_{2,2}\)</li>
</ul></li>
<li>\(Dom\)
<ul class="org-ul">
<li>\(Dom(x_{i,j}) = \{1, 9\}\)</li>
</ul></li>
<li>\(C\)
<ul class="org-ul">
<li>\(alldiff(x_{0,0}, x_{0,1}, \ldots, x_{2,2})\)</li>
<li>\( x_{i,0} + x_{i,1} + x_{i,2} = 15 (i = 0, 1, 2) \)</li>
<li>\( x_{0,j} + x_{1,j} + x_{2,j} = 15 (j = 0, 1, 2) \)</li>
<li>\( x_{0,0} + x_{1,1} + x_{2,2} = 15 \)</li>
<li>\( x_{0,2} + x_{1,1} + x_{2,0} = 15 \)</li>
</ul></li>
</ul>
</blockquote>

<ul class="org-ul">
<li>ここで alldiff はCSPのグローバル制約の一つ Alldifferent 制約であり，与えられた引数が互いに異なることを表す．</li>
<li>すなわち alldiff(\(x_1, x_2, \ldots, x_n\)) は \(x_i \ne x_j\) (for all  \(i < j\)) と同じである．</li>
<li>CSPを記述したファイルは以下のようになる <a href="hoge/files/ex-magicsq.sc">ex-magicsq.sc</a></li>
</ul>
<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._

reset
int('x(0,0), 1, 9); int('x(0,1), 1, 9); int('x(0,2), 1, 9)
int('x(1,0), 1, 9); int('x(1,1), 1, 9); int('x(1,2), 1, 9)
int('x(2,0), 1, 9); int('x(2,1), 1, 9); int('x(2,2), 1, 9)
add(alldiff(
  'x(0,0), 'x(0,1), 'x(0,2),
  'x(1,0), 'x(1,1), 'x(1,2),
  'x(2,0), 'x(2,1), 'x(2,2)
))
add('x(0,0) + 'x(0,1) + 'x(0,2) === 15)
add('x(1,0) + 'x(1,1) + 'x(1,2) === 15)
add('x(2,0) + 'x(2,1) + 'x(2,2) === 15)
add('x(0,0) + 'x(1,0) + 'x(2,0) === 15)
add('x(0,1) + 'x(1,1) + 'x(2,1) === 15)
add('x(0,2) + 'x(1,2) + 'x(2,2) === 15)
add('x(0,0) + 'x(1,1) + 'x(2,2) === 15)
add('x(0,2) + 'x(1,1) + 'x(2,0) === 15)
</pre>
</div>

<ul class="org-ul">
<li>ただこの書き方だともっと大きい魔方陣のプログラムを書くのは大変．</li>
<li>Scala の制御構造やクラスを利用すればもっと以下のように簡潔に記述できる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._, dsl._

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">xs</span> = <span style="color: #a020f0;">for</span> (i &lt;- 1 to 3; j &lt;- 1 to 3) <span style="color: #a020f0;">yield</span> int('x(i,j), 1, 9)
add(alldiff(xs))

<span style="color: #a020f0;">for</span> (i &lt;- 1 to 3)
  add(Sum((1 to 3).map(j =&gt; 'x(i,j))) === 15)
<span style="color: #a020f0;">for</span> (j &lt;- 1 to 3)
  add(Sum((1 to 3).map(i =&gt; 'x(i,j))) === 15)

add(Sum((1 to 3).map(i =&gt; 'x(i,i))) === 15)
add(Sum((1 to 3).map(i =&gt; 'x(i,4-i))) === 15)
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline11"></a>練習問題<br  /><div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>n x n の魔方陣を記述してみよう．</li>
</ul>
</div></li></ol>
</div>


<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">6.3</span> 正方形矩形パッキング</h3>
<div class="outline-text-3" id="text-6-3">
<pre class="example">
正方形詰込み問題 SP(n,s) は一辺の長さ 1 から n まで1ずつ増加する正方形の集合を
一辺の長さ s の正方形の枠内に重なりなく配置する問題である．
</pre>



<div class="figure">
<p><img src="figs/spp15.png" alt="spp15.png" width="400px" />
</p>
</div>

<ul class="org-ul">
<li>最も素直なモデリングは整数変数 \(x_{i}, y_{i} \in \{0, \ldots, s-i\}\) をそれぞれの正方形 \(i~(1 \le i \le n)\) に \((x_{i},~y_{i})\) が正方形 \(i\) の左下の座標を指すようにするものである．</li>
<li>以下の制約は任意の二つの正方形 \(i\) と \(j\) (但し \(1\le i < j \le n\)) が重なることを禁止する．
<ul class="org-ul">
<li>\((x_{i}+i \le x_{j}) \vee (x_{j}+j \le x_{i}) \vee (y_{i}+i \le y_{j}) \vee (y_{j}+j \le y_{i})\)</li>
</ul></li>
</ul>

<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">import</span> jp.kobe_u.scarab._ , dsl._

<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">n</span> = 15
<span style="color: #a020f0;">val</span> <span style="color: #a0522d;">s</span> = 100

<span style="color: #a020f0;">var</span> <span style="color: #a0522d;">lb</span> = 15
<span style="color: #a020f0;">var</span> <span style="color: #a0522d;">ub</span> = s
int('m, lb, ub)

<span style="color: #a020f0;">for</span> (i &lt;- 1 to n) { 
  int('x(i),0,s-i) 
  int('y(i),0,s-i) 
}

<span style="color: #a020f0;">for</span> (i &lt;- 1 to n)
  add(('x(i)+i &lt;= 'm) &amp;&amp; ('y(i)+i &lt;= 'm)) 

<span style="color: #a020f0;">for</span> (i &lt;- 1 to n; j &lt;- i+1 to n) 
  add(('x(i)+i&lt;='x(j)) || ('x(j)+j&lt;='x(i)) || ('y(i)+i&lt;='y(j)) || ('y(j)+j&lt;='y(i)))

<span style="color: #a020f0;">while</span>(lb &lt;= ub &amp;&amp; find('m &lt;= ub)) {
  add('m &lt;= ub)
  ub -= 1
  println(ub)
}
</pre>
</div>
<ul class="org-ul">
<li>最適化部分は1ずつ下げているが，もっと良い方法がある．</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">6.4</span> その他の例題</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li><a href="http://www.csplib.org/Problems/prob024/">ラングフォード・ペアリング</a></li>
<li>プログラム例は <a href="http://tsoh.org/scarab/examples.html">Scarab の Example</a> ページにある．</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-2">
<h2 id="orgheadline31"><span class="section-number-2">7</span> その他 Scarab の説明クラスとメソッドの簡単なまとめ</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">7.1</span> jar ファイルとソースコード</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>scarab を jar ファイルにまとめたものです</li>
<li>scala -cp scarab-v196-s212.jar などどすることで, scarab を利用できま
す</li>
<li>使用している Scala のバージョンに応じて，以下から適切な scarab jar
を選択してダウンロードしてください．
<ul class="org-ul">
<li>(for Scala 2.12.*) use <a href="jars/scarab-v196-s212.jar">jars/scarab-v196-s212.jar</a></li>
<li>(for Scala 2.11.*) use <a href="jars/scarab-v196-s211.jar">jars/scarab-v196-s211.jar</a></li>
<li>(for Scala 2.10.*) use <a href="jars/scarab-v196-s210.jar">jars/scarab-v196-s210.jar</a></li>
<li>ソースコードは <a href="https://github.com/TakehideSoh/Scarab">Github </a>から入手できます．</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">7.2</span> Scarab DSL の制約記述に関する構文 (BNF記法)</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li><b>V</b>, <b>T</b>, <b>C</b>, <b>B</b> を <b>Var</b> (整数変数), <b>Term</b> (項), <b>Constraint</b> (制約), <b>Bool</b> (ブール変数) に対応するScarabオブジェクトとする.</li>
<li>Int, String, Any は Scala のオブジェクトとする．</li>
<li>制約に関する Scarab DSL の構文は以下のように定義される．</li>
</ul>
<pre class="example">
T  ::= V | -T | T + Int | T + T | T - Int | T - T | T * Int | Sum(V, ...) | Sum(Seq(V, ...))  
V  ::= Var(String, String, ...) | V(Any, ...)
C  ::= B | T op T | !C | C &amp;&amp; C | C || C | alldiff(Seq(T, ...)) |  
      And(C, ...) | And(Seq(C, ...)) | Or(C, ...) | Or(Seq(C, ...))
op ::= &lt;= | &lt; | =&gt; | &gt; | === | !==
B  ::= Bool(String, String, ...) | B(Any, ...)
</pre>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">7.3</span> Scarab のクラス図</h3>
<div class="outline-text-3" id="text-7-3">
</div><ol class="org-ol"><li><a id="orgheadline18"></a>CSPに関係するクラス図<br  /><div class="outline-text-4" id="text-7-3-1">
<center>

<div class="figure">
<p><img src="figs/class_diagram_csp.png" alt="class_diagram_csp.png" />
</p>
</div>
</center>
</div></li>

<li><a id="orgheadline19"></a>制約ソルバーに関係するクラス図<br  /><div class="outline-text-4" id="text-7-3-2">
<center>

<div class="figure">
<p><img src="figs/class_diagram_solver.png" alt="class_diagram_solver.png" />
</p>
</div>
</center>
</div></li></ol>
</div>


<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30"><span class="section-number-3">7.4</span> プログラムの簡単なまとめ</h3>
<div class="outline-text-3" id="text-7-4">
</div><ol class="org-ol"><li><a id="orgheadline23"></a>項オブジェクト (Termオブジェクト)<br  /><ol class="org-ol"><li><a id="orgheadline21"></a>整数変数オブジェクト (Varオブジェクト)<br  /><div class="outline-text-5" id="text-7-4-1-1">
<ul class="org-ul">
<li>整数変数オプジェクトは Var で生成する． 引数にはその名前を与える．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">x</span> = Var(<span style="color: #8b2252;">"x"</span>)
x: jp.kobe_u.scarab.Var = x
</pre>
</div>
<ul class="org-ul">
<li>名前がない場合は，新しい匿名変数オブジェクトが生成される．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; <span style="color: #a020f0;">val</span> <span style="color: #a0522d;">z</span> = Var()
z: jp.kobe_u.scarab.Var = TMP_I_1
</pre>
</div>
<ul class="org-ul">
<li>Varオブジェクトに添字を与えることで，新しいVarオブジェクトを生成できる． 添字には整数や文字列を使用でき，また複数与えても良い． ただし，添字にScarabの整数変数を用いることはできない．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; x(<span style="color: #8b2252;">"book"</span>, <span style="color: #8b2252;">"apple"</span>, 300)
res16: jp.kobe_u.scarab.Var = x(book,apple,300)
</pre>
</div>
<ul class="org-ul">
<li>Scala の Symbol は，Varオブジェクトに暗黙変換される．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; 'abc(2)
res19: jp.kobe_u.scarab.Var = abc(2)
</pre>
</div>
<ul class="org-ul">
<li>Varオブジェクトは後述の項 (Term) オブジェクトの一種である．</li>
</ul>
</div></li>

<li><a id="orgheadline22"></a>和算オブジェクト (Sumオブジェクト)<br  /><div class="outline-text-5" id="text-7-4-1-2">
<ul class="org-ul">
<li>Sumオブジェクトは整数変数の加算 (\(+\))，減算 (\(-\)) を表す．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; Sum('x + 'y)
res21: jp.kobe_u.scarab.Sum = Sum(+x+y)

scala&gt; Sum(- 'x - 'y)
res22: jp.kobe_u.scarab.Sum = Sum(-x-y)

scala&gt; - Sum(- 'x - 'y)
res23: jp.kobe_u.scarab.Sum = Sum(+x+y)
</pre>
</div>
</div></li></ol></li>

<li><a id="orgheadline24"></a>制約オブジェクト<br  /><div class="outline-text-4" id="text-7-4-2">
<ul class="org-ul">
<li>Termオブジェクトと比較演算子 &lt;= (\(\le\)), &lt;, &gt;= (\(\ge\)), &gt;, <code>=</code> (\(=\)),　!== (\(\ne\)) の組合せで構成される．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; Sum('x - 'y) &lt;= 3
res25: jp.kobe_u.scarab.Constraint = LeZero(Sum(-3+x-y))
</pre>
</div>
<ul class="org-ul">
<li>宣言されると同時に &lt;= 0 の形に正規化される．</li>
</ul>
</div></li>

<li><a id="orgheadline27"></a>CSPオブジェクト<br  /><div class="outline-text-4" id="text-7-4-3">
<ul class="org-ul">
<li>CSPオブジェクトは，制約充足問題を表すオブジェクトである． jp.kobe_u.scarab.dsl._ を import した場合， デフォールトのCSPオブジェクトを変数 csp として参照できる．</li>
</ul>
</div>
<ol class="org-ol"><li><a id="orgheadline25"></a>整数変数の宣言 (CSPへ整数変数を追加)<br  /><div class="outline-text-5" id="text-7-4-3-1">
<ul class="org-ul">
<li>整数変数は int メソッドで宣言する． 通常は，下限値と上限値を与える．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; int('x, 0, 10)
res27: jp.kobe_u.scarab.Var = x
</pre>
</div>
<ul class="org-ul">
<li>飛び飛びのドメインも利用できる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; int('y, Seq(1,3,5))
res28: jp.kobe_u.scarab.Var = y
</pre>
</div>
<ul class="org-ul">
<li>変数のドメインは，csp.dom メソッドで確認できる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; csp.dom('x)
res29: jp.kobe_u.scarab.Domain = Domain(0 to 10)

scala&gt; csp.dom('y)
res30: jp.kobe_u.scarab.Domain = Domain(1,3,5)
</pre>
</div>
</div></li>

<li><a id="orgheadline26"></a>制約の追加<br  /><div class="outline-text-5" id="text-7-4-3-2">
<ul class="org-ul">
<li>制約の追加は add メソッドで宣言する．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; add('x === 'y * 2)
res31: jp.kobe_u.scarab.Constraint = EqZero(Sum(+x-2*y))
</pre>
</div>
<ul class="org-ul">
<li>現時点での変数宣言と制約は show で確認できる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; show
int(x,Domain(0 to 10))
int(y,Domain(1,3,5))
EqZero(Sum(+x-2*y))
</pre>
</div>
</div></li></ol></li>

<li><a id="orgheadline28"></a>解の探索<br  /><div class="outline-text-4" id="text-7-4-4">
<ul class="org-ul">
<li>最初の解の探索は find で行う．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; find
res34: Boolean = <span style="color: #008b8b;">true</span>
</pre>
</div>
<ul class="org-ul">
<li>結果が true なら解が存在し，false なら存在しない． 見つかった解は solution で表示される．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; solution
res35: jp.kobe_u.scarab.Assignment = Assignment(Map(x -&gt; 10, y -&gt; 5),Map())
</pre>
</div>
<ul class="org-ul">
<li>変数を solution への引数として与えれば，値が得られる．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; solution('x)
res37: Int = 10
</pre>
</div>
<ul class="org-ul">
<li>find メソッド中では，以下が実行されている．
<ul class="org-ul">
<li>CSPオブジェクトをSAT符号化し，SATソルバーへ節を追加</li>
<li>SATソルバーによる解探索を実行</li>
<li>SATソルバーが発見した解をCSPの解に復号化</li>
</ul></li>
<li>次の解は findNext で求める．</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">scala&gt; findNext
res38: Boolean = <span style="color: #008b8b;">true</span>

scala&gt; solution
res39: jp.kobe_u.scarab.Assignment = Assignment(Map(x -&gt; 6, y -&gt; 3),Map())
</pre>
</div>
<ul class="org-ul">
<li>findNextメソッド中では，以下が実行されている．
<ul class="org-ul">
<li>現在の解の否定を表す条件をソルバーに追加</li>
<li>追加したCNFに対し，SATソルバーによる解探索を実行</li>
<li>SATソルバーの発見した解をCSPの解に復号化</li>
</ul></li>
</ul>
</div></li>

<li><a id="orgheadline29"></a>その他<br  /><div class="outline-text-4" id="text-7-4-5">
<ul class="org-ul">
<li>SATソルバーを切り替えるには以下のようにする</li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">use(<span style="color: #a020f0;">new</span> Sat4jPB)
use(<span style="color: #a020f0;">new</span> ExtSatSolver(<span style="color: #8b2252;">"minisat"</span>))
</pre>
</div>
<ul class="org-ul">
<li>外部SATソルバー (ExtSatSolver) の引数には実行パスを入れる．</li>
<li>エンコーダを切り替えるには以下のようにする
<ul class="org-ul">
<li>デフォルトは OrderEncoder</li>
</ul></li>
</ul>
<div class="org-src-container">

<pre class="src src-scala">use(<span style="color: #a020f0;">new</span> NativePBEncoder(csp, satSolver))
use(<span style="color: #a020f0;">new</span> LogEncoder(csp, satSolver))
</pre>
</div>
<ul class="org-ul">
<li>各種符号化・機能とSatSolverの対応表は以下になる．</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Sat4j</th>
<th scope="col" class="org-left">Sat4jPB</th>
<th scope="col" class="org-left">ExtSolver</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">OrderEncoder</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
</tr>

<tr>
<td class="org-left">LogEncorder</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">NativePBEncoder</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">x</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">インクリメンタルSAT</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">仮説</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">x</td>
</tr>

<tr>
<td class="org-left">極小非充足コア</td>
<td class="org-left">o</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
</tr>
</tbody>
</table>
</div></li></ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Takehide Soh</p>
<p class="date">Created: 2019-02-26 火 02:14</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

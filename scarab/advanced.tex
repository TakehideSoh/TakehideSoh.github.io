% Created 2015-05-25 æœˆ 16:50
\documentclass[compress,dvipdfmx]{beamer}
\usetheme{default}
\author{\href{http://kix.istc.kobe-u.ac.jp/~soh/}{Takehide Soh}}
\date{\today}
\title{Scarab: Advanced Solving Techniques}
\begin{document}

\maketitle


\begin{frame}[label=sec-1]{Developers can Construct their own SAT-based Systems.}
\begin{block}{Since Scarab is designed to be an useful workbench rather than a final product, constraint models and search strategies are intended to be modeled and/or customized to meet developers' requirement.}
\end{block}
\begin{block}{This page provides some examples of customizing \alert{alldiff constraints} and \alert{search strategies}.}
\end{block}
\end{frame}

\begin{frame}[fragile,label=sec-2]{Customizing Alldiff Constraint}
 \begin{block}{We consider the following 4 models of $alldiff(x_{1}, x_{2}, \ldots, x_{n})$}
\end{block}

\begin{block}{\alert{Alldiff 1}: Original Alldiff.}
$\bigwedge_{i<j} (x_{i} \ne x_{j})$
\begin{verbatim}
1  def alldiff(xs: Seq[Var]) = {
2    And(And(for (Seq(x, y) <- xs.combinations(2)) yield x !== y))
3  }
\end{verbatim}
\end{block}
\begin{block}{\alert{Alldiff 2}: Alldiff with Permutaion Constraints}
\(\bigwedge_{i<j} (x_{i} \ne x_{j}) \wedge \bigwedge_{i=lb}^{ub}\left(\bigvee_{j=1}^{n} (x_{j}=i)\right)\)
\begin{verbatim}
1  def alldiff(xs: Seq[Var]) = {
2    var lb = for (x <- xs) yield csp.dom(x).lb 
3    var ub = for (x <- xs) yield csp.dom(x).ub 
4    And(
5      And(for (Seq(x, y) <- xs.combinations(2)) yield x !== y),
6      And(for (num <- lb.min to ub.max) yield Or(for (x <- xs) yield x === num))
7    )
8  }
\end{verbatim}
\end{block}

\begin{block}{\alert{Alldiff 3}: Alldiff with Pigeon Hole Constraints}
$\bigwedge_{i<j} (x_{i} \ne x_{j}) \wedge \neg\bigwedge_{i=1}^{n}(x_{i} < lb + n - 1) \wedge \neg\bigwedge_{i=1}^{n}(x_{i} > ub - n+ 1)$
\begin{verbatim}
1  def alldiff(xs: Seq[Var]) = {
2    var lb = for (x <- xs) yield csp.dom(x).lb 
3    var ub = for (x <- xs) yield csp.dom(x).ub 
4    And(
5      And(for (Seq(x, y) <- xs.combinations(2)) yield x !== y),
6      Or(for (x <- xs) yield !(x < lb.min+xs.size-1)),
7      Or(for (x <- xs) yield !(x > ub.max-xs.size+1))
8    )
9  }
\end{verbatim}
\end{block}
\begin{block}{\alert{Alldiff 4}: Alldiff with Permutation and Pigeon Hole Constraints}
$\bigwedge_{i<j} (x_{i} \ne x_{j}) \wedge \bigwedge_{i=lb}^{ub}\left(\bigvee_{j=1}^{n} (x_{j}=i)\right) \wedge \neg\bigwedge_{i=1}^{n}(x_{i} < lb + n - 1) \wedge \neg\bigwedge_{i=1}^{n}(x_{i} > ub - n+ 1)$
\begin{verbatim}
 1  def alldiff(xs: Seq[Var]) = {
 2    var lb = for (x <- xs) yield csp.dom(x).lb 
 3    var ub = for (x <- xs) yield csp.dom(x).ub 
 4    And(
 5      And(for (Seq(x, y) <- xs.combinations(2)) yield x !== y),
 6      And(for (num <- lb.min to ub.max) yield Or(for (x <- xs) yield x === num)),
 7      Or(for (x <- xs) yield !(x < lb.min+xs.size-1)),
 8      Or(for (x <- xs) yield !(x > ub.max-xs.size+1))
 9    )
10  }
\end{verbatim}
\end{block}
\begin{block}{\alert{Experiments on Latin Square}: We compared the 4 models with the following Latin Square program. Results are available below.}
\begin{verbatim}
 1  import jp.kobe_u.scarab.csp._
 2  import jp.kobe_u.scarab.solver._
 3  import jp.kobe_u.scarab.sapp._
 4  
 5  var n: Int = 5
 6  for (i <- 1 to n; j <- 1 to n)  int('x(i,j),1,n) 
 7  for (i <- 1 to n) {
 8    add(alldiff((1 to n).map(j => 'x(i,j))))
 9    add(alldiff((1 to n).map(j => 'x(j,i))))
10    add(alldiff((1 to n).map(j => 'x(j,(i+j-1)%n+1))))
11    add(alldiff((1 to n).map(j => 'x(j,(i+(j-1)*(n-1))%n+1))))}
12  
13  if (find)  println(solution)
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[label=sec-3]{Experimental Results for Latin Square}
\begin{block}{We compare the above 4 types of alldiff constraints written in Scarab.}
\begin{table}[htb]
\caption{Results for Latin Square of Sizes 7 to 16 (2.93GHz CPU, 3600 sec. T.O.)}
\centering
\begin{tabular}{lrrrrrrlrrrr}
\hline
 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & \#Total\\
\hline
Alldiff 1 & 0.210 & T.O. & T.O. & T.O. & 0.347 & T.O. & T.O. & T.O. & T.O. & T.O. & 2\\
Alldiff 2 & 0.232 & 0.245 & 0.230 & 0.391 & 0.317 & 1.150 & T.O. & 14.309 & 953.0 & 1303.0 & 9\\
Alldiff 3 & 0.265 & 0.306 & 0.219 & 0.332 & 0.252 & 0.885 & T.O. & 9.826 & 423.3 & 840.7 & 9\\
Alldiff 4 & 0.221 & 0.212 & 0.235 & 0.370 & 0.332 & 0.981 & 0.545 & 9.792 & 389.9 & 458.1 & \alert{10}\\
\hline
\end{tabular}
\end{table}
\end{block}

\begin{block}{The best performance is achieved by Alldiff (4), which has extra permutation and pigeon hole constraints.}
\end{block}
\begin{block}{As is shown in \href{./examples.html}{here}, all alldiff constraints are implemented less than 10 lines.}
\end{block}
\begin{block}{\alert{Implementing your ideas and trials are easy in Scarab!}}
\end{block}
\end{frame}


\begin{frame}[fragile,label=sec-4]{Modeling Search Strategies}
 \begin{block}{In the following, we provide some examples of how to write search strategies.}
\end{block}
\begin{block}{The first one is decremental search for Square Packing.}
\begin{verbatim}
 1  import jp.kobe_u.scarab.csp._
 2  import jp.kobe_u.scarab.solver._
 3  import jp.kobe_u.scarab.sapp._
 4  
 5  val n = 15; val s =36 
 6  
 7  for (i <- 1 to n)  { int('x(i),0,s-i) ; int('y(i),0,s-i) }
 8  for (i <- 1 to n; j <- i+1 to n) 
 9    add(('x(i)+i<='x(j)) || ('x(j)+j<='x(i)) || ('y(i)+i<='y(j)) || ('y(j)+j<='y(i)))
10  
11  if (find) println(solution.intMap) 
12  
13  var lb = 15; var ub = s; int('m, lb, ub)
14  for (i <- 1 to n)
15    add(('x(i)+i <= 'm) && ('y(i)+i <= 'm)) 
16  
17  while(lb <= ub && find('m <= ub)) {
18    add('m <= ub); ub -= 1
19  }
20  
21  while(find)  println(solution.intMap)
\end{verbatim}
\begin{block}{(Lines 13 to 15) add constraints for optimization}
\end{block}
\begin{block}{(Lines 17 to 19) decremental search}
\end{block}
\begin{block}{(Line 21) enumerate optimal solutions}
\end{block}
\end{block}

\begin{block}{Incremental Search}
\begin{verbatim}
1  var lb = 15; var ub = s; int('m, lb, ub)
2  for (i <- 1 to n)
3    add(('x(i)+i <= 'm) && ('y(i)+i <= 'm)) 
4  
5  while(lb < ub && !find('m <= lb)) {
6    add('m > lb); lb += 1
7  }
8  
9  while(find)  println(solution.intMap)
\end{verbatim}
\begin{block}{(Lines 1 to 3) add constraints for optimization}
\end{block}
\begin{block}{(Lines 5 to 7) decremental search}
\end{block}
\begin{block}{(Line 9) enumerate optimal solutions}
\end{block}
\end{block}

\begin{block}{Binary Search}
\begin{verbatim}
 1  var lb = 5; var ub = s
 2  commit
 3  while(lb < ub) {
 4    var size = (lb + ub) / 2
 5    for (i <- 1 to n)
 6      add(('x(i)+i<=size)&&('y(i)+i<=size))
 7    if (find) {
 8      ub = size; commit;
 9    } else {
10      lb = size + 1; rollback;
11    }
12  }
\end{verbatim}
\begin{block}{(Lines 3 to 12) binary search}
\end{block}
\end{block}
\end{frame}
% Emacs 24.3.1 (Org mode 8.2.10)
\end{document}
